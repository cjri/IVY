//Program to calculate predicted sigma values for loci in a model system, where data is generated by a sampling process
//This code uses a deterministic method to run the underlying population distribution, and samples it at low frequency

#include <iostream>
#include <sstream>
#include <vector>
#include <list>
using namespace std;

#include "seqmodel.h"
#include "io.h"
#include "modelI.h"
#include "modelV.h"
#include "modelY.h"
#include "modelX.h"
#include "utilities.h"

int main(int argc, const char **argv){

    //Code to read in an alignment.
    //Identifies variants and will make covariance matrix between these sites.
    
    //Initialise random number generator
    
	run_params p;
	GetParameters(p,argc,argv);
    p.seed=(int) time(NULL);
    gsl_rng_env_setup();
    gsl_rng *rgen = gsl_rng_alloc (gsl_rng_taus);
    gsl_rng_set (rgen, p.seed);

    //Read in sequence data
    vector<string> seqs;
    //Read in sequence alignment
    ReadFastaAli (p,seqs);
    if (seqs.size()==0) {
        cout << "Error: No sequence data\n";
        return 0;
    }
    //Read times for each sample
    vector<int> times;
    ReadTimes (p,times);
    if (times.size()!=seqs.size()) {
        cout << "Error: Mismatch between time and sequence data\n";
        return 0;
    }


    //Find consensus sequence
    string all_consensus;
    FindConsensus(all_consensus,seqs);
    vector<sparseseq> variants;
    FindVariants (variants,all_consensus,seqs);

    if (p.fix==1) {  //Need to adapt to amend the actual sequences
        FindAmbiguousVariants (variants,all_consensus,seqs);
        //Find ambiguous nucleotides and convert to N if they are unresolvable
        FixVariants(seqs,variants);  //NB Not clear we need to do this as we store data in varbin, which contains a fix in itself
        if (p.verb==1) {
            cout << "Warning: Code only written for variants R, K, Y, W.  Double check output.";
        }
    }

    WriteVariants (p,variants);

    //Find variant positions
    vector<int> varpos;
    FindVariantPositions (p,variants,varpos);
    
    //Compile variant matrix.  Note: Would need more than one if there were multiple sets
    //Convert the matrix to binary code so 0 is consensus, 1 is variant.  Note that we need fractions to account for the Ns
    vector< vector<char> > varmat;
    vector< vector<double> > varbin;
    vector<char> consensus;
    MakeVarmatVarbin2 (p,seqs,varpos,consensus,varmat,varbin);
    WriteVariantsToFile (p,consensus,variants);

    //Which variants are fixations and which are fluctuations is a question that is dependent upon which sequences
    //are considered to be within the same set.  Therefore, we want to split at this point, on getting varbin
    
    if (p.model.compare("I")==0)  { //Number of sets.  Here consider everything together
        ModelSinglePopulation(p,times,varbin,rgen);
    }

    if (p.model.compare("V")==0) {
        //Trial code for finding samples that have to go together in a population
        p.sets=2;
        //Run model V
        RunModelV (p,times,varbin,rgen);
    }
    
    if (p.model.compare("Y")==0) {
        //Trial code for finding samples that have to go together in a population
        p.sets=3;
        //Run model Y
        RunModelY (p,times,varbin,rgen);
        
    }


    if (p.model.compare("X")==0) {
        //Trial code for finding samples that have to go together in a population
        p.sets=4;
        //Run model X
        RunModelX (p,times,varbin,rgen);
        
    }

    
    return 0;

    
    //Random thought: Split at time zero but observe later than that for the first time.  Might get some substitutions in each case prior to observation.

    
    
    //Test: Find fixations and fluctuations
        //Test position by position
        //Idea: Fit better to 000011111 for some time at which change happens than to 00000 or 111111
    
    //Find all of the variant positions
    
    //Assign to sets if we have more than two
    
    //For the data in each set, divide variants into fixations and fluctuations.
    
}
	
	
